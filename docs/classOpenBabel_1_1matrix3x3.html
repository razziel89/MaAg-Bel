<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MaAg-bel: OpenBabel::matrix3x3 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MaAg-bel
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceOpenBabel.html">OpenBabel</a></li><li class="navelem"><a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classOpenBabel_1_1matrix3x3-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenBabel::matrix3x3 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a real 3x3 matrix.  
 <a href="classOpenBabel_1_1matrix3x3.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="matrix3x3_8h_source.html">openbabel/math/matrix3x3.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OpenBabel::matrix3x3:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOpenBabel_1_1matrix3x3.png" usemap="#OpenBabel::matrix3x3_map" alt=""/>
  <map id="OpenBabel::matrix3x3_map" name="OpenBabel::matrix3x3_map">
<area href="classOpenBabel_1_1transform3d.html" title="Handle 3D transformations, such as space group definitions. " alt="OpenBabel::transform3d" shape="rect" coords="0,56,148,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13cc006814b2724e7f2faf81aca45c0b"><td class="memItemLeft" align="right" valign="top"><a id="a13cc006814b2724e7f2faf81aca45c0b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a13cc006814b2724e7f2faf81aca45c0b">matrix3x3</a> (void)</td></tr>
<tr class="memdesc:a13cc006814b2724e7f2faf81aca45c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the zero-matrix. <br /></td></tr>
<tr class="separator:a13cc006814b2724e7f2faf81aca45c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3023af699c8d2ad144a50790ec7f07"><td class="memItemLeft" align="right" valign="top"><a id="a4a3023af699c8d2ad144a50790ec7f07"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a4a3023af699c8d2ad144a50790ec7f07">matrix3x3</a> (double s)</td></tr>
<tr class="memdesc:a4a3023af699c8d2ad144a50790ec7f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs s times the unit matrix. <br /></td></tr>
<tr class="separator:a4a3023af699c8d2ad144a50790ec7f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902cd72525b3ccca322fec79d1ac36c1"><td class="memItemLeft" align="right" valign="top"><a id="a902cd72525b3ccca322fec79d1ac36c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a902cd72525b3ccca322fec79d1ac36c1">matrix3x3</a> (<a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> row1, <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> row2, <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> row3)</td></tr>
<tr class="memdesc:a902cd72525b3ccca322fec79d1ac36c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a matrix from row vectors. <br /></td></tr>
<tr class="separator:a902cd72525b3ccca322fec79d1ac36c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec40b271b79b0455c1457c7e4931f99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a7ec40b271b79b0455c1457c7e4931f99">matrix3x3</a> (double d[3][3])</td></tr>
<tr class="memdesc:a7ec40b271b79b0455c1457c7e4931f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a matrix from a 3x3-array of doubles.  <a href="#a7ec40b271b79b0455c1457c7e4931f99">More...</a><br /></td></tr>
<tr class="separator:a7ec40b271b79b0455c1457c7e4931f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa937b03f65165294a46ff0628baf098c"><td class="memItemLeft" align="right" valign="top"><a id="aa937b03f65165294a46ff0628baf098c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#aa937b03f65165294a46ff0628baf098c">~matrix3x3</a> ()</td></tr>
<tr class="memdesc:aa937b03f65165294a46ff0628baf098c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:aa937b03f65165294a46ff0628baf098c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3137686450da61f77a16aa94d6fb7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a2f3137686450da61f77a16aa94d6fb7a">GetArray</a> (double *m)</td></tr>
<tr class="memdesc:a2f3137686450da61f77a16aa94d6fb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function.  <a href="#a2f3137686450da61f77a16aa94d6fb7a">More...</a><br /></td></tr>
<tr class="separator:a2f3137686450da61f77a16aa94d6fb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4673a561498d409630a0cd2cdf6f67"><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#acb4673a561498d409630a0cd2cdf6f67">operator()</a> (int row, int column) const</td></tr>
<tr class="separator:acb4673a561498d409630a0cd2cdf6f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb68fc3eaa3da6a8c7c2a8867fd918b"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a8cb68fc3eaa3da6a8c7c2a8867fd918b">operator()</a> (int row, int column)</td></tr>
<tr class="separator:a8cb68fc3eaa3da6a8c7c2a8867fd918b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ff338ccbc0e0d64d2ca507fc22cdba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#ab7ff338ccbc0e0d64d2ca507fc22cdba">inverse</a> (void) const</td></tr>
<tr class="memdesc:ab7ff338ccbc0e0d64d2ca507fc22cdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse of a matrix.  <a href="#ab7ff338ccbc0e0d64d2ca507fc22cdba">More...</a><br /></td></tr>
<tr class="separator:ab7ff338ccbc0e0d64d2ca507fc22cdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb94a6569d57ffa81a17748154b7730"><td class="memItemLeft" align="right" valign="top"><a id="a2bb94a6569d57ffa81a17748154b7730"></a>
<a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a2bb94a6569d57ffa81a17748154b7730">transpose</a> (void) const</td></tr>
<tr class="memdesc:a2bb94a6569d57ffa81a17748154b7730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the transpose of a matrix. <br /></td></tr>
<tr class="separator:a2bb94a6569d57ffa81a17748154b7730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e39fafa9a15e67c7becc45c9da86091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a7e39fafa9a15e67c7becc45c9da86091">randomRotation</a> (<a class="el" href="classOpenBabel_1_1OBRandom.html">OBRandom</a> &amp;rnd)</td></tr>
<tr class="memdesc:a7e39fafa9a15e67c7becc45c9da86091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a matrix for a random rotation.  <a href="#a7e39fafa9a15e67c7becc45c9da86091">More...</a><br /></td></tr>
<tr class="separator:a7e39fafa9a15e67c7becc45c9da86091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56d20595c3e71ad506f3557ba63e204"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#ab56d20595c3e71ad506f3557ba63e204">determinant</a> () const</td></tr>
<tr class="separator:ab56d20595c3e71ad506f3557ba63e204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd468a95d2baf9c23b9f9820c1e47ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a4dd468a95d2baf9c23b9f9820c1e47ef">isSymmetric</a> (void) const</td></tr>
<tr class="memdesc:a4dd468a95d2baf9c23b9f9820c1e47ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a matrix is symmetric.  <a href="#a4dd468a95d2baf9c23b9f9820c1e47ef">More...</a><br /></td></tr>
<tr class="separator:a4dd468a95d2baf9c23b9f9820c1e47ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2086e470dc298fd3c85c1a8511f2b0ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a2086e470dc298fd3c85c1a8511f2b0ac">isOrthogonal</a> (void) const</td></tr>
<tr class="memdesc:a2086e470dc298fd3c85c1a8511f2b0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a matrix is orthogonal.  <a href="#a2086e470dc298fd3c85c1a8511f2b0ac">More...</a><br /></td></tr>
<tr class="separator:a2086e470dc298fd3c85c1a8511f2b0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0099ae8005952fcb6ff2207dedbc48a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#af0099ae8005952fcb6ff2207dedbc48a">isDiagonal</a> (void) const</td></tr>
<tr class="separator:af0099ae8005952fcb6ff2207dedbc48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae681c3f90e9388788f459fb69542ec28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#ae681c3f90e9388788f459fb69542ec28">isUnitMatrix</a> (void) const</td></tr>
<tr class="separator:ae681c3f90e9388788f459fb69542ec28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1db77e577b7fef77bef83cc5b0f05d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a6e1db77e577b7fef77bef83cc5b0f05d">Get</a> (int row, int column) const</td></tr>
<tr class="memdesc:a6e1db77e577b7fef77bef83cc5b0f05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function.  <a href="#a6e1db77e577b7fef77bef83cc5b0f05d">More...</a><br /></td></tr>
<tr class="separator:a6e1db77e577b7fef77bef83cc5b0f05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ba0d420fa8f444003c43aa0c631b8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#ac7ba0d420fa8f444003c43aa0c631b8c">Set</a> (int row, int column, double v)</td></tr>
<tr class="memdesc:ac7ba0d420fa8f444003c43aa0c631b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function.  <a href="#ac7ba0d420fa8f444003c43aa0c631b8c">More...</a><br /></td></tr>
<tr class="separator:ac7ba0d420fa8f444003c43aa0c631b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d357422c9fb00e49ced8fb0b02ca4be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a4d357422c9fb00e49ced8fb0b02ca4be">SetColumn</a> (int column, const <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> &amp;v)</td></tr>
<tr class="memdesc:a4d357422c9fb00e49ced8fb0b02ca4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function.  <a href="#a4d357422c9fb00e49ced8fb0b02ca4be">More...</a><br /></td></tr>
<tr class="separator:a4d357422c9fb00e49ced8fb0b02ca4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99a0037229a48638c506efccf2e3404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#af99a0037229a48638c506efccf2e3404">SetRow</a> (int row, const <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> &amp;v)</td></tr>
<tr class="memdesc:af99a0037229a48638c506efccf2e3404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function.  <a href="#af99a0037229a48638c506efccf2e3404">More...</a><br /></td></tr>
<tr class="separator:af99a0037229a48638c506efccf2e3404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b328549e10f681a0859b9a9324bb72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1vector3.html">vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#ae5b328549e10f681a0859b9a9324bb72">GetColumn</a> (unsigned int col) const</td></tr>
<tr class="memdesc:ae5b328549e10f681a0859b9a9324bb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function.  <a href="#ae5b328549e10f681a0859b9a9324bb72">More...</a><br /></td></tr>
<tr class="separator:ae5b328549e10f681a0859b9a9324bb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43be73d628d11375a1a11bad706900b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1vector3.html">vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#ae43be73d628d11375a1a11bad706900b">GetRow</a> (unsigned int row) const</td></tr>
<tr class="memdesc:ae43be73d628d11375a1a11bad706900b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function.  <a href="#ae43be73d628d11375a1a11bad706900b">More...</a><br /></td></tr>
<tr class="separator:ae43be73d628d11375a1a11bad706900b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac949da9cecb6ea1ebe992071741b1a9"><td class="memItemLeft" align="right" valign="top"><a id="aac949da9cecb6ea1ebe992071741b1a9"></a>
<a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#aac949da9cecb6ea1ebe992071741b1a9">operator*=</a> (const double &amp;c)</td></tr>
<tr class="memdesc:aac949da9cecb6ea1ebe992071741b1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies all entries of the matrix by a scalar c. <br /></td></tr>
<tr class="separator:aac949da9cecb6ea1ebe992071741b1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7879ce1882b5e0c77374e03da07d5d"><td class="memItemLeft" align="right" valign="top"><a id="acb7879ce1882b5e0c77374e03da07d5d"></a>
<a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#acb7879ce1882b5e0c77374e03da07d5d">operator/=</a> (const double &amp;c)</td></tr>
<tr class="memdesc:acb7879ce1882b5e0c77374e03da07d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides all entries of the matrix by a scalar c. <br /></td></tr>
<tr class="separator:acb7879ce1882b5e0c77374e03da07d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b28eede32b739ac76e59a95e81312b"><td class="memItemLeft" align="right" valign="top"><a id="a68b28eede32b739ac76e59a95e81312b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a68b28eede32b739ac76e59a95e81312b">SetupRotMat</a> (double x, double y, double z)</td></tr>
<tr class="memdesc:a68b28eede32b739ac76e59a95e81312b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a rotation matrix for rotation about the x, y, and z axes by the angles specified (in degrees) <br /></td></tr>
<tr class="separator:a68b28eede32b739ac76e59a95e81312b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ac37405880c340e48d5248a03ad82c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#ab8ac37405880c340e48d5248a03ad82c">PlaneReflection</a> (const <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> &amp;norm)</td></tr>
<tr class="memdesc:ab8ac37405880c340e48d5248a03ad82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a matrix that represents reflection on a plane.  <a href="#ab8ac37405880c340e48d5248a03ad82c">More...</a><br /></td></tr>
<tr class="separator:ab8ac37405880c340e48d5248a03ad82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522f2abe6f4a959a70fe84c272ab4603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a522f2abe6f4a959a70fe84c272ab4603">RotAboutAxisByAngle</a> (const <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> &amp;axis, const double angle)</td></tr>
<tr class="memdesc:a522f2abe6f4a959a70fe84c272ab4603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a rotation matrix, rotating around the specified axis by the specified angle (in degrees)  <a href="#a522f2abe6f4a959a70fe84c272ab4603">More...</a><br /></td></tr>
<tr class="separator:a522f2abe6f4a959a70fe84c272ab4603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1a33b150ca4cd3d2a6d3b0b3c8c2e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#aad1a33b150ca4cd3d2a6d3b0b3c8c2e9">FillOrth</a> (double alpha, double beta, double gamma, double a, double b, double c)</td></tr>
<tr class="separator:aad1a33b150ca4cd3d2a6d3b0b3c8c2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db198da74233e164be0df23671cc2f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a0db198da74233e164be0df23671cc2f3">findEigenvectorsIfSymmetric</a> (<a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> &amp;eigenvals) const</td></tr>
<tr class="memdesc:a0db198da74233e164be0df23671cc2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the eigenvalues and -vectors of a symmetric matrix.  <a href="#a0db198da74233e164be0df23671cc2f3">More...</a><br /></td></tr>
<tr class="separator:a0db198da74233e164be0df23671cc2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7fcd32e3bd44b49e03a7b3b8b03fe62e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a7fcd32e3bd44b49e03a7b3b8b03fe62e">jacobi</a> (unsigned int n, double *a, double *d, double *v)</td></tr>
<tr class="memdesc:a7fcd32e3bd44b49e03a7b3b8b03fe62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue calculation.  <a href="#a7fcd32e3bd44b49e03a7b3b8b03fe62e">More...</a><br /></td></tr>
<tr class="separator:a7fcd32e3bd44b49e03a7b3b8b03fe62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3310e44837bc75036016ec3f6f3c3bfb"><td class="memItemLeft" align="right" valign="top">OBAPI <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#a3310e44837bc75036016ec3f6f3c3bfb">operator*</a> (const <a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a> &amp;, const <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> &amp;)</td></tr>
<tr class="memdesc:a3310e44837bc75036016ec3f6f3c3bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-vector multiplication.  <a href="#a3310e44837bc75036016ec3f6f3c3bfb">More...</a><br /></td></tr>
<tr class="separator:a3310e44837bc75036016ec3f6f3c3bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d4790042774490b158d4f129fe7b24"><td class="memItemLeft" align="right" valign="top"><a id="af3d4790042774490b158d4f129fe7b24"></a>
OBAPI <a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#af3d4790042774490b158d4f129fe7b24">operator*</a> (const <a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a> &amp;, const <a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a> &amp;)</td></tr>
<tr class="memdesc:af3d4790042774490b158d4f129fe7b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-matrix multiplication. <br /></td></tr>
<tr class="separator:af3d4790042774490b158d4f129fe7b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf2b43d83b005704287cc282d0112cb"><td class="memItemLeft" align="right" valign="top">OBAPI std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.html#aedf2b43d83b005704287cc282d0112cb">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a> &amp;)</td></tr>
<tr class="memdesc:aedf2b43d83b005704287cc282d0112cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a text representation of a matrix.  <a href="#aedf2b43d83b005704287cc282d0112cb">More...</a><br /></td></tr>
<tr class="separator:aedf2b43d83b005704287cc282d0112cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a real 3x3 matrix. </p>
<p>Rotating points in space can be performed by a vector-matrix multiplication. The <a class="el" href="classOpenBabel_1_1matrix3x3.html" title="Represents a real 3x3 matrix. ">matrix3x3</a> class is designed as a helper to the <a class="el" href="classOpenBabel_1_1vector3.html" title="Represents a vector in 3-dimensional real space. ">vector3</a> class for rotating points in space. The rotation matrix may be initialised by passing in the array of floating point values, by passing euler angles, or a rotation vector and angle of rotation about that vector. Once set, the <a class="el" href="classOpenBabel_1_1matrix3x3.html" title="Represents a real 3x3 matrix. ">matrix3x3</a> class can be used to rotate vectors by the overloaded multiplication operator. The following demonstrates the usage of the <a class="el" href="classOpenBabel_1_1matrix3x3.html" title="Represents a real 3x3 matrix. ">matrix3x3</a> class:</p>
<div class="fragment"><div class="line"><a class="code" href="classOpenBabel_1_1matrix3x3.html#a13cc006814b2724e7f2faf81aca45c0b">matrix3x3</a> mat;</div><div class="line">mat.SetupRotMat(0.0,180.0,0.0); <span class="comment">//rotate theta by 180 degrees</span></div><div class="line">vector3 v = <a class="code" href="namespaceOpenBabel.html#a5678c96e4c82931fa0f3c8324b4155f5">VX</a>;</div><div class="line">v *= mat; <span class="comment">//apply the rotation</span></div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7ec40b271b79b0455c1457c7e4931f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec40b271b79b0455c1457c7e4931f99">&#9670;&nbsp;</a></span>matrix3x3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenBabel::matrix3x3::matrix3x3 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>[3][3]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a matrix from a 3x3-array of doubles. </p>
<p>The first index represents the row, the second index the column </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab56d20595c3e71ad506f3557ba63e204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56d20595c3e71ad506f3557ba63e204">&#9670;&nbsp;</a></span>determinant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenBabel::matrix3x3::determinant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The determinant of the matrix </dd></dl>

</div>
</div>
<a id="aad1a33b150ca4cd3d2a6d3b0b3c8c2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1a33b150ca4cd3d2a6d3b0b3c8c2e9">&#9670;&nbsp;</a></span>FillOrth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::matrix3x3::FillOrth </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate an orthogonalisation matrix for a unit cell specified by the parameters alpha, beta, gamma, a, b, c where alpha, beta, and gamma are the cell angles (in degrees) and a, b, and c are the cell vector lengths Used by <a class="el" href="classOpenBabel_1_1OBUnitCell.html" title="Used for storing information about periodic boundary conditions with conversion to/from translation v...">OBUnitCell</a> </p>

</div>
</div>
<a id="a0db198da74233e164be0df23671cc2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db198da74233e164be0df23671cc2f3">&#9670;&nbsp;</a></span>findEigenvectorsIfSymmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a> OpenBabel::matrix3x3::findEigenvectorsIfSymmetric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>eigenvals</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the eigenvalues and -vectors of a symmetric matrix. </p>
<p>This method employs the static method <a class="el" href="classOpenBabel_1_1matrix3x3.html#a7fcd32e3bd44b49e03a7b3b8b03fe62e" title="Eigenvalue calculation. ">matrix3x3::jacobi</a>(...) to find the eigenvalues and eigenvectors of a symmetric matrix. On entry it is checked if the matrix really is symmetric: if <a class="el" href="classOpenBabel_1_1matrix3x3.html#a4dd468a95d2baf9c23b9f9820c1e47ef" title="Checks if a matrix is symmetric. ">isSymmetric()</a> returns 'false', an <a class="el" href="classOpenBabel_1_1OBError.html" title="Customizable error handling and logging â€“ store a message, including the method yielding the error...">OBError</a> is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>The jacobi algorithm is should work great for all symmetric 3x3 matrices. If you need to find the eigenvectors of a non-symmetric matrix, you might want to resort to the sophisticated routines of LAPACK.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eigenvals</td><td>a reference to a <a class="el" href="classOpenBabel_1_1vector3.html" title="Represents a vector in 3-dimensional real space. ">vector3</a> where the eigenvalues will be stored. The eigenvalues are ordered so that eigenvals[0] &lt;= eigenvals[1] &lt;= eigenvals[2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an orthogonal matrix whose ith column is an eigenvector for the eigenvalue eigenvals[i]. Here 'orthogonal' means that all eigenvectors have length one and are mutually orthogonal. The ith eigenvector can thus be conveniently accessed by the <a class="el" href="classOpenBabel_1_1matrix3x3.html#ae5b328549e10f681a0859b9a9324bb72" title="Access function. ">GetColumn()</a> method, as in the following example. <div class="fragment"><div class="line"><span class="comment">// Calculate eigenvectors and -values</span></div><div class="line">vector3 eigenvals;</div><div class="line"><a class="code" href="classOpenBabel_1_1matrix3x3.html#a13cc006814b2724e7f2faf81aca45c0b">matrix3x3</a> eigenmatrix = somematrix.findEigenvectorsIfSymmetric(eigenvals);</div><div class="line"></div><div class="line"><span class="comment">// Print the 2nd eigenvector</span></div><div class="line">cout &lt;&lt; eigenmatrix.GetColumn(1) &lt;&lt; endl;</div></div><!-- fragment --> With these conventions, a matrix is diagonalized in the following way: <div class="fragment"><div class="line"><span class="comment">// Diagonalize the matrix</span></div><div class="line"><a class="code" href="classOpenBabel_1_1matrix3x3.html#a13cc006814b2724e7f2faf81aca45c0b">matrix3x3</a> diagonalMatrix = eigenmatrix.inverse() * somematrix * eigenmatrix;</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6e1db77e577b7fef77bef83cc5b0f05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1db77e577b7fef77bef83cc5b0f05d">&#9670;&nbsp;</a></span>Get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OpenBabel::matrix3x3::Get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access function. </p>
<dl class="section warning"><dt>Warning</dt><dd>row or column are not in the range 0..2, zero is returned !</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000058">Deprecated:</a></b></dt><dd>use the constant operator() instead </dd></dl>

</div>
</div>
<a id="a2f3137686450da61f77a16aa94d6fb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3137686450da61f77a16aa94d6fb7a">&#9670;&nbsp;</a></span>GetArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::matrix3x3::GetArray </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access function. </p>
<p>Writes the matrix into the 1-dimensional array m, row by row. The array must be able to hold 9 doubles, otherwise your program will segfault. </p>

</div>
</div>
<a id="ae5b328549e10f681a0859b9a9324bb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b328549e10f681a0859b9a9324bb72">&#9670;&nbsp;</a></span>GetColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> OpenBabel::matrix3x3::GetColumn </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access function. </p>
<dl class="section warning"><dt>Warning</dt><dd>If col is not in the range 0..2, an exception is thrown. </dd></dl>

</div>
</div>
<a id="ae43be73d628d11375a1a11bad706900b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43be73d628d11375a1a11bad706900b">&#9670;&nbsp;</a></span>GetRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> OpenBabel::matrix3x3::GetRow </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access function. </p>
<dl class="section warning"><dt>Warning</dt><dd>If row is not in the range 0..2, an exception is thrown. </dd></dl>

</div>
</div>
<a id="ab7ff338ccbc0e0d64d2ca507fc22cdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ff338ccbc0e0d64d2ca507fc22cdba">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a> OpenBabel::matrix3x3::inverse </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the inverse of a matrix. </p>
<p>This method checks if the absolute value of the determinant is smaller than 1e-6. If so, nothing is done and an exception is thrown. Otherwise, the inverse matrix is calculated and returned. *this is not changed.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the determinant is close to zero, but not == 0.0, this method may behave in unexpected ways and return almost random results; details may depend on your particular floating point implementation. The use of this method is therefore highly discouraged, unless you are certain that the determinant is in a reasonable range, away from 0.0 (Stefan Kebekus) </dd></dl>

</div>
</div>
<a id="af0099ae8005952fcb6ff2207dedbc48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0099ae8005952fcb6ff2207dedbc48a">&#9670;&nbsp;</a></span>isDiagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenBabel::matrix3x3::isDiagonal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if a matrix is diagonal</dd></dl>
<p>This method returns true if and only if the matrix is (approximately) a diagonal matrix. The precision used by this function is 1e-6. </p>

</div>
</div>
<a id="a2086e470dc298fd3c85c1a8511f2b0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2086e470dc298fd3c85c1a8511f2b0ac">&#9670;&nbsp;</a></span>isOrthogonal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenBabel::matrix3x3::isOrthogonal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a matrix is orthogonal. </p>
<p>This method checks if a matrix is orthogonal, i.e. if all column vectors are normalized and are mutually orthogonal. A matrix is orthogonal if, and only if the transformation it describes is orthonormal. An orthonormal transformation is a transformation that preserves length and angle.</p>
<p>The check is performed using the method <a class="el" href="classOpenBabel_1_1matrix3x3.html#ae681c3f90e9388788f459fb69542ec28">isUnitMatrix()</a> to check if </p><div class="fragment"><div class="line">*<span class="keyword">this</span> * <a class="code" href="classOpenBabel_1_1matrix3x3.html#a2bb94a6569d57ffa81a17748154b7730">transpose</a>()</div></div><!-- fragment --><p> is a unit matrix. The criterion is therefore numerically quite tight. </p>

</div>
</div>
<a id="a4dd468a95d2baf9c23b9f9820c1e47ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd468a95d2baf9c23b9f9820c1e47ef">&#9670;&nbsp;</a></span>isSymmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenBabel::matrix3x3::isSymmetric </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a matrix is symmetric. </p>
<dl class="section return"><dt>Returns</dt><dd>False if there are indices i,j such that fabs(*this[i][j]-*this[j][i]) &gt; 1e-6. Otherwise, it returns true. </dd></dl>

</div>
</div>
<a id="ae681c3f90e9388788f459fb69542ec28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae681c3f90e9388788f459fb69542ec28">&#9670;&nbsp;</a></span>isUnitMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenBabel::matrix3x3::isUnitMatrix </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if a matrix is the unit matrix</dd></dl>
<p>This method returns true if and only if the matrix is (approximately) equal to the identity matrix. The precision used by this function is 1e-6. </p>

</div>
</div>
<a id="a7fcd32e3bd44b49e03a7b3b8b03fe62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcd32e3bd44b49e03a7b3b8b03fe62e">&#9670;&nbsp;</a></span>jacobi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::matrix3x3::jacobi </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eigenvalue calculation. </p>
<p>This static function computes the eigenvalues and eigenvectors of a SYMMETRIC nxn matrix. This method is used internally by <a class="el" href="namespaceOpenBabel.html" title="Global namespace for all Open Babel code. ">OpenBabel</a>, but may be useful as a general eigenvalue finder.</p>
<p>The algorithm uses Jacobi transformations. It is described e.g. in Wilkinson, Reinsch "Handbook for automatic computation,
Volume II: Linear Algebra", part II, contribution II/1. The implementation is also similar to the implementation in this book. This method is adequate to solve the eigenproblem for small matrices, of size perhaps up to 10x10. For bigger problems, you might want to resort to the sophisticated routines of LAPACK.</p>
<dl class="section note"><dt>Note</dt><dd>If you plan to find the eigenvalues of a symmetric 3x3 matrix, you will probably prefer to use the more convenient method <a class="el" href="classOpenBabel_1_1matrix3x3.html#a0db198da74233e164be0df23671cc2f3" title="Find the eigenvalues and -vectors of a symmetric matrix. ">findEigenvectorsIfSymmetric()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the size of the matrix that should be diagonalized</td></tr>
    <tr><td class="paramname">a</td><td>array of size n^2 which holds the symmetric matrix whose eigenvectors are to be computed. The convention is that the entry in row r and column c is addressed as a[n*r+c] where, of course, 0 &lt;= r &lt; n and 0 &lt;= c &lt; n. There is no check that the matrix is actually symmetric. If it is not, the behaviour of this function is undefined. On return, the matrix is overwritten with junk.</td></tr>
    <tr><td class="paramname">d</td><td>pointer to a field of at least n doubles which will be overwritten. On return of this function, the entries d[0]..d[n-1] will contain the eigenvalues of the matrix.</td></tr>
    <tr><td class="paramname">v</td><td>an array of size n^2 where the eigenvectors will be stored. On return, the columns of this matrix will contain the eigenvectors. The eigenvectors are normalized and mutually orthogonal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb4673a561498d409630a0cd2cdf6f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4673a561498d409630a0cd2cdf6f67">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double&amp; OpenBabel::matrix3x3::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a constant reference to an element of the matrix. row and column must be between 0 and 2. No check is done. </dd></dl>

</div>
</div>
<a id="a8cb68fc3eaa3da6a8c7c2a8867fd918b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb68fc3eaa3da6a8c7c2a8867fd918b">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double&amp; OpenBabel::matrix3x3::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-constant reference to an element of the matrix. row and column must be between 0 and 2. No check is done. </dd></dl>

</div>
</div>
<a id="ab8ac37405880c340e48d5248a03ad82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ac37405880c340e48d5248a03ad82c">&#9670;&nbsp;</a></span>PlaneReflection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::matrix3x3::PlaneReflection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a matrix that represents reflection on a plane. </p>
<p>Replaces *this with a matrix that represents reflection on the plane through 0 which is given by the normal vector norm.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the vector norm has length zero, this method will generate the 0-matrix. If the length of the axis is close to zero, but not == 0.0, this method may behave in unexpected ways and return almost random results; details may depend on your particular floating point implementation. The use of this method is therefore highly discouraged, unless you are certain that the length is in a reasonable range, away from 0.0 (Stefan Kebekus)</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000092">Deprecated:</a></b></dt><dd>This method will probably replaced by a safer algorithm in the future.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>Replace this method with a more fool-proof version.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>specifies the normal to the plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e39fafa9a15e67c7becc45c9da86091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e39fafa9a15e67c7becc45c9da86091">&#9670;&nbsp;</a></span>randomRotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::matrix3x3::randomRotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenBabel_1_1OBRandom.html">OBRandom</a> &amp;&#160;</td>
          <td class="paramname"><em>rnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a matrix for a random rotation. </p>
<p>The axis of the rotation will be uniformly distributed on the unit sphere and the angle will be uniformly distributed in the interval 0..360 degrees. </p>

</div>
</div>
<a id="a522f2abe6f4a959a70fe84c272ab4603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522f2abe6f4a959a70fe84c272ab4603">&#9670;&nbsp;</a></span>RotAboutAxisByAngle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::matrix3x3::RotAboutAxisByAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a rotation matrix, rotating around the specified axis by the specified angle (in degrees) </p>
<p>Replaces *this with a matrix that represents rotation about the axis by a an angle.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the vector axis has length zero, this method will generate the 0-matrix. If the length of the axis is close to zero, but not == 0.0, this method may behave in unexpected ways and return almost random results; details may depend on your particular floating point implementation. The use of this method is therefore highly discouraged, unless you are certain that the length is in a reasonable range, away from 0.0 (Stefan Kebekus)</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000093">Deprecated:</a></b></dt><dd>This method will probably replaced by a safer algorithm in the future.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>Replace this method with a more fool-proof version.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>specifies the axis of the rotation </td></tr>
    <tr><td class="paramname">angle</td><td>angle in degrees (0..360) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7ba0d420fa8f444003c43aa0c631b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ba0d420fa8f444003c43aa0c631b8c">&#9670;&nbsp;</a></span>Set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::matrix3x3::Set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access function. </p>
<dl class="section warning"><dt>Warning</dt><dd>if row or column are not in the range 0..2, nothing will happen !</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000059">Deprecated:</a></b></dt><dd>use the non-constant operator() instead </dd></dl>

</div>
</div>
<a id="a4d357422c9fb00e49ced8fb0b02ca4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d357422c9fb00e49ced8fb0b02ca4be">&#9670;&nbsp;</a></span>SetColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::matrix3x3::SetColumn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access function. </p>
<dl class="section warning"><dt>Warning</dt><dd>If column is not in the range 0..2, the vector remains unchanged and an exception is thrown. </dd></dl>

</div>
</div>
<a id="af99a0037229a48638c506efccf2e3404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99a0037229a48638c506efccf2e3404">&#9670;&nbsp;</a></span>SetRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::matrix3x3::SetRow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access function. </p>
<dl class="section warning"><dt>Warning</dt><dd>If column is not in the range 0..2, the vector remains unchanged and an exception is thrown. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a3310e44837bc75036016ec3f6f3c3bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3310e44837bc75036016ec3f6f3c3bfb">&#9670;&nbsp;</a></span>operator*</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OBAPI <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1vector3.html">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix-vector multiplication. </p>
<p>Calculates the product m*v of the matrix m and the column vector represented by v </p>

</div>
</div>
<a id="aedf2b43d83b005704287cc282d0112cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf2b43d83b005704287cc282d0112cb">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OBAPI std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>co</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1matrix3x3.html">matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output a text representation of a matrix. </p>
<p>Print a text representation of the matrix in the standardized form: [ a, b, c ] <br />
 [ d, e, f ] <br />
 [ g, h, i ] <br />
 where the letters represent the appropriate entries in the matrix. Uses the standard output format for the individual entries, separated by ", " for each column, and [ ] indicating each row. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/openbabel/math/<a class="el" href="matrix3x3_8h_source.html">matrix3x3.h</a></li>
<li>src/math/<a class="el" href="matrix3x3_8cpp.html">matrix3x3.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
