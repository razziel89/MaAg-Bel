<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MaAg-bel: OpenBabel::OBSpectrophore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MaAg-bel
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceOpenBabel.html">OpenBabel</a></li><li class="navelem"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html">OBSpectrophore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="classOpenBabel_1_1OBSpectrophore-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenBabel::OBSpectrophore Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to compute Spectrophores&trade;.  
 <a href="classOpenBabel_1_1OBSpectrophore.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="spectrophore_8h_source.html">openbabel/spectrophore.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a88544512f8d8ef06f8518270392c8f10"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a88544512f8d8ef06f8518270392c8f10">AccuracyOption</a> { <br />
&#160;&#160;<b>AngStepSize1</b>, 
<b>AngStepSize2</b>, 
<b>AngStepSize5</b>, 
<b>AngStepSize10</b>, 
<br />
&#160;&#160;<b>AngStepSize15</b>, 
<b>AngStepSize20</b>, 
<b>AngStepSize30</b>, 
<b>AngStepSize36</b>, 
<br />
&#160;&#160;<b>AngStepSize45</b>, 
<b>AngStepSize60</b>
<br />
 }</td></tr>
<tr class="separator:a88544512f8d8ef06f8518270392c8f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb46a09c48e86fc55b9098bcac5e0a6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a5fb46a09c48e86fc55b9098bcac5e0a6">NormalizationOption</a> { <b>NoNormalization</b>, 
<b>NormalizationTowardsZeroMean</b>, 
<b>NormalizationTowardsUnitStd</b>, 
<b>NormalizationTowardsZeroMeanAndUnitStd</b>
 }</td></tr>
<tr class="separator:a5fb46a09c48e86fc55b9098bcac5e0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb6ade83c43e655b1784d6bf11e0871"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a3bb6ade83c43e655b1784d6bf11e0871">StereoOption</a> { <b>NoStereoSpecificProbes</b>, 
<b>UniqueStereoSpecificProbes</b>, 
<b>MirrorStereoSpecificProbes</b>, 
<b>AllStereoSpecificProbes</b>
 }</td></tr>
<tr class="separator:a3bb6ade83c43e655b1784d6bf11e0871"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Structors</div></td></tr>
<tr class="memitem:a41de885738e0aa7f47440f0254a50555"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a41de885738e0aa7f47440f0254a50555">OBSpectrophore</a> (void)</td></tr>
<tr class="separator:a41de885738e0aa7f47440f0254a50555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a37771b90da5d338217c0d4b0666ff7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a6a37771b90da5d338217c0d4b0666ff7">OBSpectrophore</a> (const <a class="el" href="classOpenBabel_1_1OBSpectrophore.html">OBSpectrophore</a> &amp;sphore)</td></tr>
<tr class="separator:a6a37771b90da5d338217c0d4b0666ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee14969df84fdfeb985d41571a1a003a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#aee14969df84fdfeb985d41571a1a003a">~OBSpectrophore</a> (void)</td></tr>
<tr class="separator:aee14969df84fdfeb985d41571a1a003a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Overloaded operators</div></td></tr>
<tr class="memitem:a109cf3f26e34f1307ad900bc1c865a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html">OBSpectrophore</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a109cf3f26e34f1307ad900bc1c865a62">operator=</a> (const <a class="el" href="classOpenBabel_1_1OBSpectrophore.html">OBSpectrophore</a> &amp;sphore)</td></tr>
<tr class="separator:a109cf3f26e34f1307ad900bc1c865a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Set methods</div></td></tr>
<tr class="memitem:a3a3e1abb9bd837351e20ae35b953145d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a3a3e1abb9bd837351e20ae35b953145d">SetResolution</a> (const double r=3.0)</td></tr>
<tr class="separator:a3a3e1abb9bd837351e20ae35b953145d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79277ce236ee44c68acfd1754e1eb69a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a79277ce236ee44c68acfd1754e1eb69a">SetAccuracy</a> (const <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a88544512f8d8ef06f8518270392c8f10">AccuracyOption</a> a=AngStepSize20)</td></tr>
<tr class="separator:a79277ce236ee44c68acfd1754e1eb69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81acfd6fce87362a5c3130e5af4d325b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a81acfd6fce87362a5c3130e5af4d325b">SetStereo</a> (const <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a3bb6ade83c43e655b1784d6bf11e0871">StereoOption</a> s=NoStereoSpecificProbes)</td></tr>
<tr class="separator:a81acfd6fce87362a5c3130e5af4d325b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6de84c840a34c19919b7be27c7ad4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a4f6de84c840a34c19919b7be27c7ad4e">SetNormalization</a> (const <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a5fb46a09c48e86fc55b9098bcac5e0a6">NormalizationOption</a> n=NoNormalization)</td></tr>
<tr class="separator:a4f6de84c840a34c19919b7be27c7ad4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get methods</div></td></tr>
<tr class="memitem:af0da742d92848736ab6bc650c7319692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a88544512f8d8ef06f8518270392c8f10">AccuracyOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#af0da742d92848736ab6bc650c7319692">GetAccuracy</a> (void) const</td></tr>
<tr class="separator:af0da742d92848736ab6bc650c7319692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96701b95393ec3d1f3387ddf26501d03"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a96701b95393ec3d1f3387ddf26501d03">GetResolution</a> (void) const</td></tr>
<tr class="separator:a96701b95393ec3d1f3387ddf26501d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eba53b288ae8e67f9178981a7ea18e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a3bb6ade83c43e655b1784d6bf11e0871">StereoOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a08eba53b288ae8e67f9178981a7ea18e">GetStereo</a> (void) const</td></tr>
<tr class="separator:a08eba53b288ae8e67f9178981a7ea18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980b2567a6f074dd2a869aa87b90a8d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a5fb46a09c48e86fc55b9098bcac5e0a6">NormalizationOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a980b2567a6f074dd2a869aa87b90a8d0">GetNormalization</a> (void) const</td></tr>
<tr class="separator:a980b2567a6f074dd2a869aa87b90a8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0676cffcafae05b7e48f57bb272a60b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#ac0676cffcafae05b7e48f57bb272a60b">GetSpectrophore</a> (<a class="el" href="classOpenBabel_1_1OBMol.html">OpenBabel::OBMol</a> *mol)</td></tr>
<tr class="separator:ac0676cffcafae05b7e48f57bb272a60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3db75efb106efca03b195f8adb1b82c8"><td class="memItemLeft" align="right" valign="top"><a id="a3db75efb106efca03b195f8adb1b82c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_getMoleculeData</b> (<a class="el" href="classOpenBabel_1_1OBMol.html">OpenBabel::OBMol</a> *)</td></tr>
<tr class="separator:a3db75efb106efca03b195f8adb1b82c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d1332094ceb2562ed7f6e48aa6d53d"><td class="memItemLeft" align="right" valign="top"><a id="ac9d1332094ceb2562ed7f6e48aa6d53d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_orient</b> (void)</td></tr>
<tr class="separator:ac9d1332094ceb2562ed7f6e48aa6d53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f62f99dd28e14602c7e0add4765fa44"><td class="memItemLeft" align="right" valign="top"><a id="a2f62f99dd28e14602c7e0add4765fa44"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_getBox</b> (double **)</td></tr>
<tr class="separator:a2f62f99dd28e14602c7e0add4765fa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7298aca88a9e4b735d485ca4edb887f0"><td class="memItemLeft" align="right" valign="top"><a id="a7298aca88a9e4b735d485ca4edb887f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_setBox</b> (void)</td></tr>
<tr class="separator:a7298aca88a9e4b735d485ca4edb887f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa324f36774ae13e07e67ee87e4287d8"><td class="memItemLeft" align="right" valign="top"><a id="afa324f36774ae13e07e67ee87e4287d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_getEnergies</b> (double **, double *)</td></tr>
<tr class="separator:afa324f36774ae13e07e67ee87e4287d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3a9c60b396f8aa0a0ac08fb4547feb"><td class="memItemLeft" align="right" valign="top"><a id="a9e3a9c60b396f8aa0a0ac08fb4547feb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_initiateSpectrophore</b> (double *, double *)</td></tr>
<tr class="separator:a9e3a9c60b396f8aa0a0ac08fb4547feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d558a7e192e8b7dd3bcbdb2c1bb3890"><td class="memItemLeft" align="right" valign="top"><a id="a4d558a7e192e8b7dd3bcbdb2c1bb3890"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_rotateX</b> (double **, double **, const double, const double)</td></tr>
<tr class="separator:a4d558a7e192e8b7dd3bcbdb2c1bb3890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5992eac028ee2227cae429d3af9a6139"><td class="memItemLeft" align="right" valign="top"><a id="a5992eac028ee2227cae429d3af9a6139"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_rotateY</b> (double **, double **, const double, const double)</td></tr>
<tr class="separator:a5992eac028ee2227cae429d3af9a6139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2847e83dbe91a32105c63295a485bb1"><td class="memItemLeft" align="right" valign="top"><a id="ab2847e83dbe91a32105c63295a485bb1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_rotateZ</b> (double **, double **, const double, const double)</td></tr>
<tr class="separator:ab2847e83dbe91a32105c63295a485bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe054ef896e2fc1f2ff40a1b60b01409"><td class="memItemLeft" align="right" valign="top"><a id="afe054ef896e2fc1f2ff40a1b60b01409"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_updateSpectrophore</b> (double *, double *)</td></tr>
<tr class="separator:afe054ef896e2fc1f2ff40a1b60b01409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c7561b2a8d63714e12e2b2a942dbc3"><td class="memItemLeft" align="right" valign="top"><a id="aa4c7561b2a8d63714e12e2b2a942dbc3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_calculateProperties</b> (<a class="el" href="classOpenBabel_1_1OBMol.html">OpenBabel::OBMol</a> *)</td></tr>
<tr class="separator:aa4c7561b2a8d63714e12e2b2a942dbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6b80513e57baeff34243660b41e0a2"><td class="memItemLeft" align="right" valign="top"><a id="abe6b80513e57baeff34243660b41e0a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_solveMatrix</b> (double **, double *, unsigned int)</td></tr>
<tr class="separator:abe6b80513e57baeff34243660b41e0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621f2115160ac52bc43186d577daf86c"><td class="memItemLeft" align="right" valign="top"><a id="a621f2115160ac52bc43186d577daf86c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_luDecompose</b> (double **, std::vector&lt; int &gt; &amp;, unsigned int)</td></tr>
<tr class="separator:a621f2115160ac52bc43186d577daf86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d3a1837e4efe22a1412e56fe74cbb7"><td class="memItemLeft" align="right" valign="top"><a id="a16d3a1837e4efe22a1412e56fe74cbb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_luSolve</b> (double **, std::vector&lt; int &gt; &amp;, double *, unsigned int)</td></tr>
<tr class="separator:a16d3a1837e4efe22a1412e56fe74cbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0a8fbad073291b5fb4b8bc344d9409"><td class="memItemLeft" align="right" valign="top"><a id="adb0a8fbad073291b5fb4b8bc344d9409"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_swapRows</b> (double *, unsigned int, unsigned int)</td></tr>
<tr class="separator:adb0a8fbad073291b5fb4b8bc344d9409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c30a1a734288ecdb2ae02a78d36cae0"><td class="memItemLeft" align="right" valign="top"><a id="a6c30a1a734288ecdb2ae02a78d36cae0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_swapRows</b> (double **, unsigned int, unsigned int, unsigned int)</td></tr>
<tr class="separator:a6c30a1a734288ecdb2ae02a78d36cae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab3cd17d8db41a79a0d1ba0b6d68ecb21"><td class="memItemLeft" align="right" valign="top"><a id="ab3cd17d8db41a79a0d1ba0b6d68ecb21"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>_resolution</b></td></tr>
<tr class="separator:ab3cd17d8db41a79a0d1ba0b6d68ecb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48032bc85c37628edb18453a0b8274ec"><td class="memItemLeft" align="right" valign="top"><a id="a48032bc85c37628edb18453a0b8274ec"></a>
<a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a88544512f8d8ef06f8518270392c8f10">AccuracyOption</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_accuracy</b></td></tr>
<tr class="separator:a48032bc85c37628edb18453a0b8274ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5906b23f8245d77c566ea53cef8279b"><td class="memItemLeft" align="right" valign="top"><a id="af5906b23f8245d77c566ea53cef8279b"></a>
<a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a3bb6ade83c43e655b1784d6bf11e0871">StereoOption</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_stereoFlag</b></td></tr>
<tr class="separator:af5906b23f8245d77c566ea53cef8279b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3f9ee2c0428562f02d2ad401b8d508"><td class="memItemLeft" align="right" valign="top"><a id="a0a3f9ee2c0428562f02d2ad401b8d508"></a>
<a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a5fb46a09c48e86fc55b9098bcac5e0a6">NormalizationOption</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_normalization</b></td></tr>
<tr class="separator:a0a3f9ee2c0428562f02d2ad401b8d508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76499b2ebed640da85b95c5179169aa3"><td class="memItemLeft" align="right" valign="top"><a id="a76499b2ebed640da85b95c5179169aa3"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_rotationStepList</b></td></tr>
<tr class="separator:a76499b2ebed640da85b95c5179169aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2aad676f8a09798bc849a862e3d2079"><td class="memItemLeft" align="right" valign="top"><a id="ae2aad676f8a09798bc849a862e3d2079"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>_nAtoms</b></td></tr>
<tr class="separator:ae2aad676f8a09798bc849a862e3d2079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc09c713d6e4290c49ce2a3a71f0439"><td class="memItemLeft" align="right" valign="top"><a id="a7fc09c713d6e4290c49ce2a3a71f0439"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>_property</b></td></tr>
<tr class="separator:a7fc09c713d6e4290c49ce2a3a71f0439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378d4157e98b413f94bf0d1fe3420693"><td class="memItemLeft" align="right" valign="top"><a id="a378d4157e98b413f94bf0d1fe3420693"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>_radii</b></td></tr>
<tr class="separator:a378d4157e98b413f94bf0d1fe3420693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662268b0d5619672a1270671f14fa04a"><td class="memItemLeft" align="right" valign="top"><a id="a662268b0d5619672a1270671f14fa04a"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>_oricoor</b></td></tr>
<tr class="separator:a662268b0d5619672a1270671f14fa04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971e496726fe2b774f914605f90ae892"><td class="memItemLeft" align="right" valign="top"><a id="a971e496726fe2b774f914605f90ae892"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>_coor</b></td></tr>
<tr class="separator:a971e496726fe2b774f914605f90ae892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad569b4f6d3ea494c0a54f5aa5a1a98"><td class="memItemLeft" align="right" valign="top"><a id="a2ad569b4f6d3ea494c0a54f5aa5a1a98"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>_beginProbe</b></td></tr>
<tr class="separator:a2ad569b4f6d3ea494c0a54f5aa5a1a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c8ee7c4d1dcd413d7da27d6e84c0b0"><td class="memItemLeft" align="right" valign="top"><a id="aa5c8ee7c4d1dcd413d7da27d6e84c0b0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>_endProbe</b></td></tr>
<tr class="separator:aa5c8ee7c4d1dcd413d7da27d6e84c0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e7191cff280af658d614bda7a6e6e3"><td class="memItemLeft" align="right" valign="top"><a id="ac8e7191cff280af658d614bda7a6e6e3"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>_numberOfProbes</b></td></tr>
<tr class="separator:ac8e7191cff280af658d614bda7a6e6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eec0e78c2c3ba76294de3e6953c44bb"><td class="memItemLeft" align="right" valign="top"><a id="a9eec0e78c2c3ba76294de3e6953c44bb"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_spectro</b></td></tr>
<tr class="separator:a9eec0e78c2c3ba76294de3e6953c44bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98236527d49426297828da6203b7f0f"><td class="memItemLeft" ><a id="ab98236527d49426297828da6203b7f0f"></a>
struct {</td></tr>
<tr class="memitem:a5a18b33464f571674cc249504c99afef"><td class="memItemLeft" >
&#160;&#160;&#160;int&#160;&#160;&#160;<b>value</b> [12]</td></tr>
<tr class="separator:a5a18b33464f571674cc249504c99afef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98236527d49426297828da6203b7f0f"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><b>_probe</b> [48]</td></tr>
<tr class="separator:ab98236527d49426297828da6203b7f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd345cbf31598ec2f2b6dceeb3b52e6f"><td class="memItemLeft" ><a id="acd345cbf31598ec2f2b6dceeb3b52e6f"></a>
struct {</td></tr>
<tr class="memitem:adf34fdb4befe23fe70e7b3d697361ca4"><td class="memItemLeft" >
&#160;&#160;&#160;double&#160;&#160;&#160;<b>x</b></td></tr>
<tr class="separator:adf34fdb4befe23fe70e7b3d697361ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac862f43d1dfd176b307af94846539639"><td class="memItemLeft" >
&#160;&#160;&#160;double&#160;&#160;&#160;<b>y</b></td></tr>
<tr class="separator:ac862f43d1dfd176b307af94846539639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b92b43cce2ce962f90b24a6c90457e"><td class="memItemLeft" >
&#160;&#160;&#160;double&#160;&#160;&#160;<b>z</b></td></tr>
<tr class="separator:a30b92b43cce2ce962f90b24a6c90457e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d6c85bbc8cec45c7232e1fbbd00cf7"><td class="memItemLeft" >
&#160;&#160;&#160;double&#160;&#160;&#160;<b>v</b> [N_PROPERTIES]</td></tr>
<tr class="separator:a81d6c85bbc8cec45c7232e1fbbd00cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd345cbf31598ec2f2b6dceeb3b52e6f"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><b>_boxPoint</b> [12]</td></tr>
<tr class="separator:acd345cbf31598ec2f2b6dceeb3b52e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to compute Spectrophores&trade;. </p>
<dl class="section since"><dt>Since</dt><dd>Version 2.3 </dd></dl>
<h3>Introduction</h3>
<p>Spectrophores&trade; are one-dimensional descriptors generated from the property fields surrounding the molecules. The technology allows the accurate description of molecules in terms of their surface properties or fields. Comparison of molecules’ property fields provides a robust structure-independent method of aligning actives from different chemical classes. When applied to molecules such as ligands and drugs, Spectrophores&trade; can be used as powerful molecular descriptors in the fields of chemoinformatics, virtual screening, and QSAR modeling. </p>
<p>The computation of Spectrophores&trade; is independent of the position and orientation of the molecule and this enables easy and fast comparison of Spectrophores&trade; between different molecules. Molecules having similar three-dimensional properties and shapes always yield similar Spectrophores&trade;. </p>
<p>A Spectrophore&trade; is calculated by surrounding the three-dimensional conformation of the molecule by a three-dimensional arrangement of points, followed by calculating the interaction between each of the atom properties and the surrounding the points. The three-dimensional arrangement of the points surrounding the molecule can be regarded as an ‘artificial’ cage or receptor, and the interaction calculated between the molecule and the cage can be regarded as an artificial representation of an affinity value between molecule and cage. Because the calculated interaction is dependent on the relative orientation of the molecule within the cage, the molecule is rotated in discrete angles and the most favorable interaction value is kept as final result. The angular stepsize at which the molecule is rotated along its three axis can be specified by the user and influences the accuracy of the method. </p>
<h3>Atomic properties</h3>
<p>The calculation of a Spectrophore&trade; starts by calculating the atomic contributions of each property from which one wants to calculate a Spectrophore&trade; from. In the current implementation, four atomic properties are converted into a Spectrophore&trade;; these four properties include the atomic partial charges, the atomic lipohilicities, the atomic shape deviations and the atomic electrophilicities. </p>
<p>The atomic partial charges and atomic electrophilicity properties are calculated using the electronegativity equalisation method (EEM) as described by Bultinck and coworkers (<em>J. Phys. Chem.</em> 2002, <b>A106</b>, 7895-7901; <em>J. Chem. Inf. Comput. Sci.</em> 2003, <b>43</b>, 422-428). The following table lists the atomic electronegativity and hardness parameters that are used in the current implementation of the EEM method: </p><table class="doxtable">
<tr>
<td><b>Atom symbol</b></td><td><b>Atomic electronegativity</b> </td><td><b>Atomic hardness</b> </td></tr>
<tr>
<td>H</td><td><center>0.20606</center></td><td><center>0.65971</center> </td></tr>
<tr>
<td>C</td><td><center>0.36237</center></td><td><center>0.32966</center> </td></tr>
<tr>
<td>N</td><td><center>0.49279</center></td><td><center>0.34519</center> </td></tr>
<tr>
<td>O</td><td><center>0.73013</center></td><td><center>0.54428</center> </td></tr>
<tr>
<td>F</td><td><center>0.72052</center></td><td><center>0.72664</center> </td></tr>
<tr>
<td>S</td><td><center>0.62020</center></td><td><center>0.20640</center> </td></tr>
<tr>
<td>Cl</td><td><center>0.36237</center></td><td><center>0.32966</center> </td></tr>
<tr>
<td>Br</td><td><center>0.70052</center></td><td><center>0.54554</center> </td></tr>
<tr>
<td>I</td><td><center>0.68052</center></td><td><center>0.30664</center> </td></tr>
<tr>
<td>Default</td><td><center>0.36237</center></td><td><center>0.32966</center> </td></tr>
</table>
<p>Atomic lipophilic potential parameters are calculated using a rule-based method using parameters from the following table. These parameters were obtained by fitting against the logP values of 10,881 molecules. </p><table class="doxtable">
<tr>
<td><b>Atom</b></td><td><b>Lipophilicity parameter</b> </td></tr>
<tr>
<td>H bound to C</td><td><center>-0.018</center> </td></tr>
<tr>
<td>H bound to heteroatom</td><td><center>-0.374</center> </td></tr>
<tr>
<td>C</td><td><center>+0.271</center> </td></tr>
<tr>
<td>N</td><td><center>-0.137</center> </td></tr>
<tr>
<td>O</td><td><center>-0.321</center> </td></tr>
<tr>
<td>F</td><td><center>+0.217</center> </td></tr>
<tr>
<td>S</td><td><center>+0.385</center> </td></tr>
<tr>
<td>Cl</td><td><center>+0.632</center> </td></tr>
<tr>
<td>Br</td><td><center>+0.815</center> </td></tr>
<tr>
<td>I</td><td><center>+0.198</center> </td></tr>
<tr>
<td>Default</td><td><center>-0.175</center> </td></tr>
</table>
<p>Finally, the atomic shape deviation is generated by calculating, for each atom, the atom’s deviation from the average molecular radius. This is done in a four steps process:</p><ul>
<li>The molecular center of geometry (COG) is calculated;</li>
<li>The distances between each atom and the molecular COG are calculated;</li>
<li>The average molecular radius is calculated by averaging all the atomic distances.</li>
<li>The distances between each atom and the COG are then divided by the average molecular radius and centered on zero. </li>
</ul>
<h3>Interaction between the atoms and cage points</h3>
<p>Following the calculation of all required atomic properties, the next step in the calculation of a Spectrophore&trade; consists of determining the total interaction value <em>V(c,p)</em> between each of the atomic contributions of property <em>p</em> with a set of interaction points on an artificial cage <em>c</em> surrounding the molecular conformation. For this purpose, each of these interaction points <em>i</em> on cage <em>c</em> is assigned a value <em>P(c,i)</em> which is either +1 or -1, with the constraint that the sum of all interaction points on a particular cage should be zero. In a typical Spectrophore&trade; calculation, a cage is represented as a rectangular box encompassing the molecular conformation in all three dimensions, with the centers of the box edges being the interaction points. Such a configuration gives twelve interaction points per cage, and, in the case of a non-stereospecific distribution of the interaction points, leads to 12 different cages. Although there are no particular requirements as to the dimensions of the rectangular cage, the distance between the interaction points and the geometrical extremes of the molecule should be such that a meaningful interaction value between each cage point and the molecular entity can be calculated. In this respect, the default dimensions of the cage are constantly adjusted to enclose the molecule at a minimum distance of 3 &Aring; along all dimensions. This cage size can be modified by the user and influences the resolution of the Spectrophore&trade;. </p>
<div class="image">
<img src="spectrophore_cage.png" alt="spectrophore_cage.png"/>
<div class="caption">
Schematic representation of a molecule surrounded by the artifical cage</div></div>
<p>The total interaction value <em>V(c,p)</em> between the atomic contribution values <em>A(j,p)</em> of property <em>p</em> for a given molecular conformation and the cage interaction values <em>P(c,i)</em> for a given cage <em>c</em> is calculated according a standard interaction energy equation. It takes into account the Euclidean distance between each atom and each cage point. This total interaction <em>V(c,p)</em> for a given property <em>p</em> and cage <em>c</em> for a given molecular conformation is minimized by sampling the molecular orientation along the three axis in angular steps and the calculation of the interaction value for each orientation within the cage. The final total interaction <em>V(c,p)</em> for a given cage <em>c</em> and property <em>p</em> corresponds to the lowest interaction value obtained this way, and corresponds to the <em>c</em>’th value in the one-dimensional Spectrophore&trade; vector calculated for molecular property <em>p</em>. As a result, a Spectrophore&trade; is organized as a vector of minimized interaction values <em>V</em>, each of these organized in order of cages and property values. Since for a typical Spectrophore&trade; implementation twelve different cages are used, the total length of a Spectrophore&trade; vector equals to 12 times the number of properties. Since four different properties are used in the current implementation (electrostatic, lipophilic, electrophilic potentials, and an additional shape index as described before), this leads to a total Spectrophore&trade; length of 48 real values per molecular conformation. </p>
<p>Since Spectrophore&trade; descriptors are dependent on the actual three-dimensional conformation of the molecule, a typical analysis includes the calculation of Spectrophores&trade; from a reasonable set of different conformations. It is then up to the user to decide on the most optimal strategy for processing the different Spectrophore&trade; vectors. In a typical virtual screening application, calculating the average Spectrophore&trade; vector from all conformations of a single molecule may be a good strategy; other applications have benefit from calculating a weighted average or the minimal values. </p>
<h3>Accuracy</h3>
<p>As already mentioned, the total interaction between cage and molecule for a given property is minimized by sampling the molecular orientation in angular steps of a certain magnitude. As a typical angular step size, 20º was found to be the best compromise between accuracy and computer speed. Larger steps sizes are faster to calculate but have the risk of missing the global interaction energy minimum, while smaller angular steps sizes do sample the rotational space more thoroughly but at a significant computational cost. The accuracy can be specified by the user using the <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a79277ce236ee44c68acfd1754e1eb69a">OBSpectrophore::SetAccuracy(const OBSpectrophore::AccuracyOption)</a> method. </p>
<h3>Resolution</h3>
<p>Spectrophores&trade; capture information about the property fields surrounding the molecule, and the amount of detail that needs to be captured can be regulated by the user. This is done by altering the minimal distance between the molecule and the surrounding cage. The resolution can be specified by the user with the <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a3a3e1abb9bd837351e20ae35b953145d">OBSpectrophore::SetResolution(const double)</a> method. The default distance along all dimensions is 3.0 &Aring;. The larger the distance, the lower the resolution. With a higher resolution, more details of the property fields surrounding the molecule are contained by the Spectrophore&trade;. On the contrary, low resolution settings may lead to a more general representation of the property fields, with little or no emphasis on small local variations within the fields. Using a low resolution can be the method of choice during the initial virtual screening experiments in order to get an initial, but not so discriminative, first selection. This initial selection can then further be refined during subsequent virtual screening steps using a higher resolution. In this setting, small local differences in the fields between pairs of molecules will be picked up much more easily. </p>
<p>The absolute values of the individual Spectrophore&trade; data points are dependent on the used resolution. Low resolution values lead to small values of the calculated individual Spectrophore&trade; data points, while high resolutions will lead to larger data values. It is therefore only meaningful to compare only Spectrophores&trade; that have been generated using the same resolution settings or after some kind of normalization is performed. </p>
<p>Computation time is not influenced by the specified resolution, hence the computation time is identical for all different resolution settings. </p>
<h3>Stereospecificity</h3>
<p>Some of the cages that are used to calculated Spectrophores&trade; have a stereospecific distribution of the interaction points. The resulting interaction valus resulting from these cages are therefore sensitive to the enantiomeric configuration of the molecule within the cage. The fact that both stereoselective as well as stereo non-selective cages can be used makes it possible to include or exclude stereospecificity in the virtual screening search. Depending on the desired output, the stereospecificity of Spectrophores&trade; can be specified by the user:</p><ul>
<li>No stereospecificity (default). Spectrophores&trade; are generated using cages that are not stereospecific. For most applications, these Spectrophores&trade; will suffice.</li>
<li>Unique stereospecificity. Spectrophores&trade; are generated using unique stereospecific cages.</li>
<li>Mirror stereospecificity. Mirror stereospecific Spectrophores&trade; are Spectrophores&trade; resulting from the mirror enantiomeric form of the input molecules. </li>
</ul>
<p>The stereospecificity can be specified by the user using the <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a81acfd6fce87362a5c3130e5af4d325b">OBSpectrophore::SetStereo(const OBSpectrophore::StereoOption)</a> method. </p>
<p>The differences between the corresponding data points of unique and mirror stereospecific Spectrophores&trade; are very small and require very long calculation times to obtain a sufficiently high quality level. This increased quality level is triggered by the accuracy setting and will result in calculation times being increased by at least a factor 100. As a consequence, it is recommended to apply this increased accuracy only in combination with a limited number of molecules, and when the small differences between the stereospecific Spectrophores&trade; are really critical. However, for the vast majority of virtual screening applications, this increased accuracy is not required as long as it is not the intention to draw conclusions about differences in the underlying molecular stereoselectivity. Non-stereospecific Spectrophores&trade; will therefore suffice for most applications. </p>
<h3>Normalisation</h3>
<p>It may sometimes be desired to focus on the relative differences between the Spectrophore&trade; data points rather than focussing on the absolute differences. In these cases, normalization of Spectrophores&trade; may be required. The current implementation offers with the <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a4f6de84c840a34c19919b7be27c7ad4e">OBSpectrophore::SetNormalization(const OBSpectrophore::NormalizationOption)</a> method the possibility to normalize in four different ways:</p><ul>
<li>No normalization (default);</li>
<li>Normalization towards zero mean;</li>
<li>Normalization towards standard deviation;</li>
<li>Normalization towards zero mean and unit standard deviation. </li>
</ul>
<p>In all these cases, normalization is performed on a ‘per-property’ basis, which means that the data points belonging to the same property set are treated as a single set and that normalization is only performed on the data points within each of these sets and not across all data points. </p>
<p>Normalization may be important when comparing the Spectrophores&trade; of charged molecules with those of neutral molecules. For molecules carrying a global positive charge, the resulting Spectrophore&trade; data points of the charge and electrophilicity properties will both be shifted in absolute value compared to the corresponding data points of the respective neutral species. Normalization of the Spectrophores&trade; removes the original magnitude differences for the data points corresponding to the charge and electrophilicity properties of charged and neutral species. Therefore, if the emphasis of the virtual screening consists of the identification of molecules with similar property fields without taking into account differences in absolute charge, then Spectrophores&trade; should be normalized towards zero mean. However, if absolute charge differences should be taken into account to differentiate between molecules, unnormalized Spectrophores&trade; are recommended. </p>
<dl class="section since"><dt>Since</dt><dd>version 2.3 </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a88544512f8d8ef06f8518270392c8f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88544512f8d8ef06f8518270392c8f10">&#9670;&nbsp;</a></span>AccuracyOption</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a88544512f8d8ef06f8518270392c8f10">OpenBabel::OBSpectrophore::AccuracyOption</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Accuracy options </p>

</div>
</div>
<a id="a5fb46a09c48e86fc55b9098bcac5e0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb46a09c48e86fc55b9098bcac5e0a6">&#9670;&nbsp;</a></span>NormalizationOption</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a5fb46a09c48e86fc55b9098bcac5e0a6">OpenBabel::OBSpectrophore::NormalizationOption</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Normalisation options </p>

</div>
</div>
<a id="a3bb6ade83c43e655b1784d6bf11e0871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb6ade83c43e655b1784d6bf11e0871">&#9670;&nbsp;</a></span>StereoOption</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a3bb6ade83c43e655b1784d6bf11e0871">OpenBabel::OBSpectrophore::StereoOption</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stereo options </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a41de885738e0aa7f47440f0254a50555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41de885738e0aa7f47440f0254a50555">&#9670;&nbsp;</a></span>OBSpectrophore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenBabel::OBSpectrophore::OBSpectrophore </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor to create an <a class="el" href="classOpenBabel_1_1OBSpectrophore.html" title="Class to compute Spectrophores™. ">OBSpectrophore</a> object. </p>

</div>
</div>
<a id="a6a37771b90da5d338217c0d4b0666ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a37771b90da5d338217c0d4b0666ff7">&#9670;&nbsp;</a></span>OBSpectrophore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenBabel::OBSpectrophore::OBSpectrophore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1OBSpectrophore.html">OBSpectrophore</a> &amp;&#160;</td>
          <td class="paramname"><em>sphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor to create an <a class="el" href="classOpenBabel_1_1OBSpectrophore.html" title="Class to compute Spectrophores™. ">OBSpectrophore</a> object by taking a copy from another <a class="el" href="classOpenBabel_1_1OBSpectrophore.html" title="Class to compute Spectrophores™. ">OBSpectrophore</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sphore</td><td>A reference to the source <a class="el" href="classOpenBabel_1_1OBSpectrophore.html" title="Class to compute Spectrophores™. ">OBSpectrophore</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee14969df84fdfeb985d41571a1a003a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee14969df84fdfeb985d41571a1a003a">&#9670;&nbsp;</a></span>~OBSpectrophore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenBabel::OBSpectrophore::~OBSpectrophore </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default destructor object </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af0da742d92848736ab6bc650c7319692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0da742d92848736ab6bc650c7319692">&#9670;&nbsp;</a></span>GetAccuracy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a88544512f8d8ef06f8518270392c8f10">OBSpectrophore::AccuracyOption</a> OpenBabel::OBSpectrophore::GetAccuracy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the accuracy at which Spectrophores&trade; will be calculated.</p>
<dl class="section return"><dt>Returns</dt><dd>The accuracy expressed as an <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a88544512f8d8ef06f8518270392c8f10">OBSpectrophore::AccuracyOption</a> enumeration type. For a link between the returned value and the angular step size, see the <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a79277ce236ee44c68acfd1754e1eb69a">OBSpectrophore::SetAccuracy(const OBSpectrophore::AccuracyOption)</a> method. </dd></dl>

</div>
</div>
<a id="a980b2567a6f074dd2a869aa87b90a8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980b2567a6f074dd2a869aa87b90a8d0">&#9670;&nbsp;</a></span>GetNormalization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a5fb46a09c48e86fc55b9098bcac5e0a6">OBSpectrophore::NormalizationOption</a> OpenBabel::OBSpectrophore::GetNormalization </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the normalization settings at which Spectrophores&trade; will be calculated.</p>
<dl class="section return"><dt>Returns</dt><dd>The normalization treatmet expressed as an <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a5fb46a09c48e86fc55b9098bcac5e0a6">OBSpectrophore::NormalizationOption</a> enumeration type. For a link between the returned value and the normalization treatment, see the <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a4f6de84c840a34c19919b7be27c7ad4e">OBSpectrophore::SetNormalization(const OBSpectrophore::NormalizationOption)</a> method. </dd></dl>

</div>
</div>
<a id="a96701b95393ec3d1f3387ddf26501d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96701b95393ec3d1f3387ddf26501d03">&#9670;&nbsp;</a></span>GetResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenBabel::OBSpectrophore::GetResolution </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the resolution at which Spectrophores&trade; will be calculated.</p>
<dl class="section return"><dt>Returns</dt><dd>The resolution in &Aring; units </dd></dl>

</div>
</div>
<a id="ac0676cffcafae05b7e48f57bb272a60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0676cffcafae05b7e48f57bb272a60b">&#9670;&nbsp;</a></span>GetSpectrophore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; OpenBabel::OBSpectrophore::GetSpectrophore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenBabel_1_1OBMol.html">OpenBabel::OBMol</a> *&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calling this method starts the calculation of the Spectrophore&trade;. After succesful calculation, the Spectrophore&trade; is returned as a standard vector of 48 doubles. The 48 doubles are organised into 4 sets of 12 doubles each:-</p><ul>
<li>numbers 01-11: Spectrophore&trade; values calculated from the atomic partial charges;</li>
<li>numbers 13-24: Spectrophore&trade; values calculated from the atomic lipophilicity properties;</li>
<li>numbers 25-36: Spectrophore&trade; values calculated from the atomic shape deviations;</li>
<li>numbers 37-48: Spectrophore&trade; values calculated from the atomic electrophilicity properties;</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classOpenBabel_1_1OBConversion.html">OpenBabel::OBConversion</a> obconversion;</div><div class="line">obconversion.<a class="code" href="classOpenBabel_1_1OBConversion.html#a5cc5325bf5ed68ef8fcb3f5f7e89ca65">SetInFormat</a>(<span class="stringliteral">&quot;sdf&quot;</span>);</div><div class="line"><a class="code" href="classOpenBabel_1_1OBMol.html">OpenBabel::OBMol</a> mol;</div><div class="line"><a class="code" href="classOpenBabel_1_1OBSpectrophore.html">OpenBabel::OBSpectrophore</a> s;</div><div class="line">s.<a class="code" href="classOpenBabel_1_1OBSpectrophore.html#a79277ce236ee44c68acfd1754e1eb69a">SetAccuracy</a>(OpenBabel::OBSpectrophore::AngStepSize20);          <span class="comment">// Default</span></div><div class="line">s.<a class="code" href="classOpenBabel_1_1OBSpectrophore.html#a3a3e1abb9bd837351e20ae35b953145d">SetResolution</a>(3.0);                                             <span class="comment">// Default</span></div><div class="line">s.<a class="code" href="classOpenBabel_1_1OBSpectrophore.html#a81acfd6fce87362a5c3130e5af4d325b">SetStereo</a>(OpenBabel::OBSpectrophore::NoStereoSpecificProbes);   <span class="comment">// Default</span></div><div class="line">s.<a class="code" href="classOpenBabel_1_1OBSpectrophore.html#a4f6de84c840a34c19919b7be27c7ad4e">SetNormalization</a>(OpenBabel::OBSpectrophore::NoNormalization);   <span class="comment">// Default</span></div><div class="line">std::ifstream ifs;</div><div class="line">ifs.open(argv[1]);</div><div class="line"><span class="keywordflow">while</span> (obconversion.<a class="code" href="classOpenBabel_1_1OBConversion.html#aa65e920e79a2cf9838d459c36bd819f7">Read</a>(&amp;mol, &amp;ifs))</div><div class="line">{</div><div class="line">   std::vector&lt;double&gt; result = s.<a class="code" href="classOpenBabel_1_1OBSpectrophore.html#ac0676cffcafae05b7e48f57bb272a60b">GetSpectrophore</a>(&amp;mol);</div><div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i(0); i &lt; result.size(); ++i)</div><div class="line">   {</div><div class="line">      <span class="keywordflow">if</span> (!(i%12)) std::cerr &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; result[i] &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>;</div><div class="line">   }</div><div class="line">   std::cerr &lt;&lt; std::endl;</div><div class="line">   mol.<a class="code" href="classOpenBabel_1_1OBMol.html#abc7fc1c95a9c0b627771e5f58c9998d6">Clear</a>();</div><div class="line">}</div></div><!-- fragment --> <pre class="fragment">     \param   mol Pointer to the OBMol object from which to calculate a
              Spectrophore&amp;tm;. For proper functioning, the input molecule
              should have all explicit hydrogens assigned and the molecule
              should have a three-dimensional conformation assigned. It is
              the responsability of the programmer to make sure that the
              molecule is in the desired protonation state.

     \return  The calculated Spectrophore&amp;tm; as a standard vector of 48
              doubles. An empty vector of doubles is returned in case an
              error occurred during the calculation. For example, this could
              happen in the case that the molecule contains less than three
              atoms. It is therefore up to the user to check the size of the
              returned vector to capture errors.</pre> 
</div>
</div>
<a id="a08eba53b288ae8e67f9178981a7ea18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eba53b288ae8e67f9178981a7ea18e">&#9670;&nbsp;</a></span>GetStereo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a3bb6ade83c43e655b1784d6bf11e0871">OBSpectrophore::StereoOption</a> OpenBabel::OBSpectrophore::GetStereo </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the stereoselectivity setting at which Spectrophores&trade; will be calculated.</p>
<dl class="section return"><dt>Returns</dt><dd>The level of stereospecificity expressed as an <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a3bb6ade83c43e655b1784d6bf11e0871">OBSpectrophore::StereoOption</a> enumeration type. For a link between the returned value and the stereoselectivity treatment, see the <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a81acfd6fce87362a5c3130e5af4d325b">OBSpectrophore::SetStereo(const OBSpectrophore::StereoOption)</a> method. </dd></dl>

</div>
</div>
<a id="a109cf3f26e34f1307ad900bc1c865a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109cf3f26e34f1307ad900bc1c865a62">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1OBSpectrophore.html">OBSpectrophore</a> &amp; OpenBabel::OBSpectrophore::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1OBSpectrophore.html">OBSpectrophore</a> &amp;&#160;</td>
          <td class="paramname"><em>sphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator that assigns a source <a class="el" href="classOpenBabel_1_1OBSpectrophore.html" title="Class to compute Spectrophores™. ">OBSpectrophore</a> object to the target <a class="el" href="classOpenBabel_1_1OBSpectrophore.html" title="Class to compute Spectrophores™. ">OBSpectrophore</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sphore</td><td>A reference to the source <a class="el" href="classOpenBabel_1_1OBSpectrophore.html" title="Class to compute Spectrophores™. ">OBSpectrophore</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the new target <a class="el" href="classOpenBabel_1_1OBSpectrophore.html" title="Class to compute Spectrophores™. ">OBSpectrophore</a> object </dd></dl>

</div>
</div>
<a id="a79277ce236ee44c68acfd1754e1eb69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79277ce236ee44c68acfd1754e1eb69a">&#9670;&nbsp;</a></span>SetAccuracy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::OBSpectrophore::SetAccuracy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a88544512f8d8ef06f8518270392c8f10">AccuracyOption</a>&#160;</td>
          <td class="paramname"><em>a</em> = <code>AngStepSize20</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to set the accuracy at which Spectrophores&trade; will be calculated.</p>
<p>Sets the accuracy by which Spectrophores&trade; are calculated. The accuracy is linked to the angular step increment that is used to calculate Spectrophores&trade;. The accuracy parameter is an enumeration type defined by <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a88544512f8d8ef06f8518270392c8f10">OBSpectrophore::AccuracyOption</a>. should be a number ranging between 0 and 9 (inclusive), where a value of 9 means a very high accuracy, and 0 means no accuracy at all. Values between 2-6 are a good compromise between accuracy and speed. The following table provides the link between the parameter value and the angular step size: </p><table class="doxtable">
<tr>
<td><b>Accuracy</b></td><td><b><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a88544512f8d8ef06f8518270392c8f10">OBSpectrophore::AccuracyOption</a> parameter</b></td><td><b>Minimal angular steps size</b> </td></tr>
<tr>
<td>Extremely high</td><td><center>AngStepSize1</center></td><td><center>1º</center> </td></tr>
<tr>
<td>Extremely high</td><td><center>AngStepSize2</center></td><td><center>2º</center> </td></tr>
<tr>
<td>Very High</td><td><center>AngStepSize5</center></td><td><center>5º</center> </td></tr>
<tr>
<td>Very high</td><td><center>AngStepSize10</center></td><td><center>10º</center> </td></tr>
<tr>
<td>High</td><td><center>AngStepSize15</center></td><td><center>15º</center> </td></tr>
<tr>
<td>Default</td><td><center>AngStepSize20</center></td><td><center>20º</center> </td></tr>
<tr>
<td>Low</td><td><center>AngStepSize30</center></td><td><center>30º</center> </td></tr>
<tr>
<td>Very low</td><td><center>AngStepSize36</center></td><td><center>36º</center> </td></tr>
<tr>
<td>Extremely low</td><td><center>AngStepSize45</center></td><td><center>45º</center> </td></tr>
<tr>
<td>Extremely low</td><td><center>AngStepSize60</center></td><td><center>60º</center> </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The desired accuracy expressed as an <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a88544512f8d8ef06f8518270392c8f10">OBSpectrophore::AccuracyOption</a> enumeration type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f6de84c840a34c19919b7be27c7ad4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6de84c840a34c19919b7be27c7ad4e">&#9670;&nbsp;</a></span>SetNormalization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::OBSpectrophore::SetNormalization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a5fb46a09c48e86fc55b9098bcac5e0a6">NormalizationOption</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>NoNormalization</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to set the desired normalization treatment of the calculated Spectrophores&trade;.</p>
<p>The following table provides the link between the parameter value and the desired normalization treatment: </p><table class="doxtable">
<tr>
<td><b>Normalization treatment</b></td><td><b><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a5fb46a09c48e86fc55b9098bcac5e0a6">OBSpectrophore::NormalizationOption</a> parameter</b> </td></tr>
<tr>
<td>No normalisation (default)</td><td><center>NoNormalization</center> </td></tr>
<tr>
<td>Normalization towards zero mean</td><td><center>NormalizationTowardsZeroMean</center> </td></tr>
<tr>
<td>Normalization towards unit standard deviation</td><td><center>NormalizationTowardsUnitStd</center> </td></tr>
<tr>
<td>Normalization towards zero mean and unit standard deviation</td><td><center>NormalizationTowardsZeroMeanAndUnitStd</center> </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The desired normalization treatment expressed as an <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a5fb46a09c48e86fc55b9098bcac5e0a6">OBSpectrophore::NormalizationOption</a> enumeration type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a3e1abb9bd837351e20ae35b953145d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3e1abb9bd837351e20ae35b953145d">&#9670;&nbsp;</a></span>SetResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::OBSpectrophore::SetResolution </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>r</em> = <code>3.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to set the resolution at which Spectrophores&trade; will be calculated.</p>
<p>Sets the resolution at which Spectrophores&trade; are calculated. The resolution is an arbitrary positive number larger than 0.0, and is used to increase the box size for the calculation of Spectrophores&trade; in all directions. For example, a resolution of 3 means that the box size will be increased by a value of 3 &Aring; in all directions. Smaller values for the resolution have the effect that small differences in the atomic properties will result in more enhanced differences in the resulting Spectrophores&trade;, while larger resolution values will result in the smoothing of local property differences. All values &lt;= 0.0 are automatically reset to the default value of 3.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The desired resolution expressed as a double number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81acfd6fce87362a5c3130e5af4d325b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81acfd6fce87362a5c3130e5af4d325b">&#9670;&nbsp;</a></span>SetStereo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::OBSpectrophore::SetStereo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a3bb6ade83c43e655b1784d6bf11e0871">StereoOption</a>&#160;</td>
          <td class="paramname"><em>s</em> = <code>NoStereoSpecificProbes</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to set the required stereoselectivity of the resulting Spectrophores&trade;.</p>
<p>Sets the stereoselectivity of the generated Spectrophores&trade;. This is achieved by selecting the appropriate probes for the calculation. In the default case that no stereoselectivity is required, only non-stereospecific probes are used in the calculation. Stereospecific differences between enantiomers are only captured in combination with a very high accuracy, hence leading to very long computation times. The following table provides the link between the parameter value and the desired stereochemical treatment: </p><table class="doxtable">
<tr>
<td><b>Stereo treatment</b></td><td><b><a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a3bb6ade83c43e655b1784d6bf11e0871">OBSpectrophore::StereoOption</a> parameter</b> </td></tr>
<tr>
<td>Non-stereospecific probes (default)</td><td><center>NoStereoSpecificProbes</center> </td></tr>
<tr>
<td>Only the mirror stereospecific probes</td><td><center>UniqueStereoSpecificProbes</center> </td></tr>
<tr>
<td>Only the unique stereospecific probes</td><td><center>MirrorStereoSpecificProbes</center> </td></tr>
<tr>
<td>All stereospecific probes (unique and mirror)</td><td><center>AllStereoSpecificProbes</center> </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The desired stereospecificity treatment expressed as an <a class="el" href="classOpenBabel_1_1OBSpectrophore.html#a3bb6ade83c43e655b1784d6bf11e0871">OBSpectrophore::StereoOption</a> enumeration type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/openbabel/<a class="el" href="spectrophore_8h_source.html">spectrophore.h</a></li>
<li>src/<a class="el" href="spectrophore_8cpp.html">spectrophore.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
